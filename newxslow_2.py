# -*- coding: utf-8 -*-
"""newxSlow 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vKXY0IxzS1YcUQtnjMXmAANV_7Y-kZbp
"""

# Установка необходимых библиотек
!pip install tensorflow pandas scikit-learn matplotlib scapy

# Импортирование библиотек
import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from scapy.all import sniff, IP, TCP
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
import matplotlib.pyplot as plt
from sklearn.metrics import roc_curve, auc
from collections import defaultdict

# Загрузка готового датасета
df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/slowL/cic-data-0948-1010-2.csv')

from google.colab import drive
drive.mount('/content/drive')

# Преобразование временной метки в числовой формат
df['time'] = pd.to_datetime(df['time'], infer_datetime_format=True).astype(int) / 10**9

# Извлечение признаков и меток
features = df[['src_port', 'dst_port', 'window_size', 'time', 'total_forward_packets', 'total_backward_packets']].values
labels = df['label'].values

# Стандартизация признаков
scaler = StandardScaler()
features_scaled = scaler.fit_transform(features)

# Разделение данных на обучающую и тестовую выборки
X_train, X_test, y_train, y_test = train_test_split(features_scaled, labels, test_size=0.2, random_state=42)

# Создание модели нейронной сети
model = Sequential([
    Dense(16, activation='relu', input_shape=(X_train.shape[1],)),
    Dense(8, activation='relu'),
    Dense(1, activation='sigmoid')
])

# Компиляция модели
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Обучение модели с сохранением истории
history = model.fit(X_train, y_train, epochs=10, batch_size=32, validation_data=(X_test, y_test))

# Визуализация истории обучения
history_df = pd.DataFrame(history.history)
history_df['epoch'] = history.epoch

# График потерь
plt.figure(figsize=(12, 6))
plt.plot(history_df['epoch'], history_df['loss'], label='Training Loss')
plt.plot(history_df['epoch'], history_df['val_loss'], label='Validation Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.title('Training and Validation Loss Over Epochs')
plt.legend()
plt.show()

# График точности
plt.figure(figsize=(12, 6))
plt.plot(history_df['epoch'], history_df['accuracy'], label='Training Accuracy')
plt.plot(history_df['epoch'], history_df['val_accuracy'], label='Validation Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.title('Training and Validation Accuracy Over Epochs')
plt.legend()
plt.show()

# Оценка модели на тестовых данных
loss, accuracy = model.evaluate(X_test, y_test)
print(f'Test Accuracy: {accuracy:.2f}')

# ROC-кривая и выбор оптимального порога
y_pred_prob = model.predict(X_test).ravel()
fpr, tpr, thresholds = roc_curve(y_test, y_pred_prob)
roc_auc = auc(fpr, tpr)

plt.figure()
plt.plot(fpr, tpr, color='darkorange', lw=2, label='ROC curve (area = %0.2f)' % roc_auc)
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic')
plt.legend(loc="lower right")
plt.show()

optimal_idx = np.argmax(tpr - fpr)
optimal_threshold = thresholds[optimal_idx]
print(f'Optimal threshold: {optimal_threshold}')

# Функция для обнаружения атак
def detect_slowloris_attack(packet_data, threshold=0.5):
    df_new = pd.DataFrame(packet_data)
    df_new.fillna(0, inplace=True)

    if 'time' not in df_new.columns:
        df_new['time'] = pd.Timestamp.now().timestamp()  # Добавляем текущее время, если отсутствует

    df_new['time'] = pd.to_datetime(df_new['time']).astype(int) / 10**9  # Преобразование временной метки

    # Добавляем проверку наличия всех необходимых столбцов
    required_columns = ['src_port', 'dst_port', 'window_size', 'time', 'total_forward_packets', 'total_backward_packets']
    for col in required_columns:
        if col not in df_new.columns:
            df_new[col] = 0

    features_new = df_new[required_columns].values
    features_new_scaled = scaler.transform(features_new)
    predictions = model.predict(features_new_scaled)

    # Интерпретация результатов
    results = []
    for i, prediction in enumerate(predictions):
        result = 'Attack' if prediction > threshold else 'Normal'
        results.append({
            'packet': packet_data[i],
            'prediction': prediction[0],
            'result': result
        })
    return results

# Сканирование пакетов по IP-адресу
def scan_packets(ip_address, count=100, threshold=0.7):
    forward_packets = defaultdict(int)
    backward_packets = defaultdict(int)

    def packet_handler(packet):
        if packet.haslayer(IP) and packet.haslayer(TCP):
            if packet[IP].src == ip_address:
                forward_packets[packet[IP].dst] += 1
                packet_info = {
                    'src_port': packet[TCP].sport,
                    'dst_port': packet[TCP].dport,
                    'window_size': packet[TCP].window,
                    'time': packet.time,
                    'total_forward_packets': forward_packets[packet[IP].dst],
                    'total_backward_packets': backward_packets[packet[IP].dst]
                }
                print(packet_info)  # Вывод информации о пакете
                return packet_info
            elif packet[IP].dst == ip_address:
                backward_packets[packet[IP].src] += 1
                packet_info = {
                    'src_port': packet[TCP].sport,
                    'dst_port': packet[TCP].dport,
                    'window_size': packet[TCP].window,
                    'time': packet.time,
                    'total_forward_packets': forward_packets[packet[IP].src],
                    'total_backward_packets': backward_packets[packet[IP].src]
                }
                print(packet_info)  # Вывод информации о пакете
                return packet_info

    sniffed_packets = sniff(count=count, prn=packet_handler)
    sniffed_packets = [pkt for pkt in sniffed_packets if pkt]  # Удаление None значений
    results = detect_slowloris_attack(sniffed_packets, threshold=threshold)

    return results

# Работа скрипта
ip_address_to_scan = '10.0.2.15'  # IP-адрес для сканирования
results = scan_packets(ip_address_to_scan, count=50, threshold=optimal_threshold)

# Вывод результатов
for result in results:
    print(f"Prediction: {result['prediction']:.2f}, Result: {result['result']}")

# 157 rows